use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::error::Error;
use std::fmt;

// Custom error type for agent operations
#[derive(Debug)]
pub struct AgentError {
    pub message: String,
    pub kind: AgentErrorKind,
}

#[derive(Debug)]
pub enum AgentErrorKind {
    ThoughtGenerationFailed,
    ActionFailed,
    ObservationFailed,
    MemoryAccessFailed,
    LLMError,
}

impl fmt::Display for AgentError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl Error for AgentError {}

// Represents a thought generated by the agent
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Thought {
    pub content: String,
    pub next_action: Option<Action>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

// Represents an action that can be performed by the agent
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Action {
    pub action_type: String,
    pub parameters: serde_json::Value,
}

// Represents an observation made by the agent
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Observation {
    pub content: String,
    pub source: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub metadata: Option<serde_json::Value>,
}

// Represents the agent's working memory
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Memory {
    pub observations: Vec<Observation>,
    pub thoughts: Vec<Thought>,
    pub actions_taken: Vec<Action>,
}

// Main trait defining the agent's capabilities
#[async_trait]
pub trait Agent {
    // Core capabilities
    async fn think(&mut self, context: &str) -> Result<Thought, AgentError>;
    async fn observe(&mut self, target: &str) -> Result<Observation, AgentError>;
    async fn execute(&mut self, action: Action) -> Result<Observation, AgentError>;
    
    // Memory management
    fn get_memory(&self) -> &Memory;
    fn update_memory(&mut self, thought: Option<Thought>, observation: Option<Observation>, action: Option<Action>);
    
    // Tool usage
    async fn use_tool(&self, tool_name: &str, params: serde_json::Value) -> Result<serde_json::Value, AgentError>;
}

// Helper struct for implementing agents
pub struct AgentBuilder {
    pub llm_config: LLMConfig,
    pub tools: Vec<Tool>,
    pub initial_memory: Option<Memory>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct LLMConfig {
    pub model: String,
    pub temperature: f32,
    pub max_tokens: u32,
}

#[derive(Debug, Clone)]
pub struct Tool {
    pub name: String,
    pub description: String,
    pub handler: Box<dyn Fn(serde_json::Value) -> Result<serde_json::Value, AgentError> + Send + Sync>,
}

impl AgentBuilder {
    pub fn new(llm_config: LLMConfig) -> Self {
        Self {
            llm_config,
            tools: Vec::new(),
            initial_memory: None,
        }
    }

    pub fn with_tool(mut self, tool: Tool) -> Self {
        self.tools.push(tool);
        self
    }

    pub fn with_initial_memory(mut self, memory: Memory) -> Self {
        self.initial_memory = Some(memory);
        self
    }
}

// Default implementation for common agent behaviors
#[async_trait]
impl<T: Agent + Send + Sync> AgentBehavior for T {
    async fn run_flow_of_thoughts(&mut self, context: &str) -> Result<Vec<Observation>, AgentError> {
        let mut observations = Vec::new();
        
        // Generate initial thought
        let thought = self.think(context).await?;
        self.update_memory(Some(thought.clone()), None, None);
        
        // Execute action if present
        if let Some(action) = thought.next_action {
            let observation = self.execute(action.clone()).await?;
            self.update_memory(None, Some(observation.clone()), Some(action));
            observations.push(observation);
        }
        
        Ok(observations)
    }
}

// Trait for common agent behaviors
#[async_trait]
pub trait AgentBehavior {
    async fn run_flow_of_thoughts(&mut self, context: &str) -> Result<Vec<Observation>, AgentError>;
}

// Helper functions for agent implementations
pub mod utils {
    use super::*;

    pub fn create_thought(content: String, next_action: Option<Action>) -> Thought {
        Thought {
            content,
            next_action,
            timestamp: chrono::Utc::now(),
        }
    }

    pub fn create_observation(
        content: String,
        source: String,
        metadata: Option<serde_json::Value>,
    ) -> Observation {
        Observation {
            content,
            source,
            timestamp: chrono::Utc::now(),
            metadata,
        }
    }

    pub fn create_action(
        action_type: String,
        parameters: serde_json::Value,
    ) -> Action {
        Action {
            action_type,
            parameters,
        }
    }
}
////////